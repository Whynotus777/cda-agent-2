"""
A6 - EDA Command Copilot

Generates and validates Yosys/OpenSTA TCL scripts from design intents.
Target: â‰¥90% first-run script validity.
"""

import json
import subprocess
import tempfile
import time
from pathlib import Path
from typing import Dict, Any, Optional, List, Tuple
import logging

from .base_agent import BaseAgent, AgentOutput

logger = logging.getLogger(__name__)


class A6_EDACommandCopilot(BaseAgent):
    """
    EDA Command Copilot - Generates valid TCL scripts for EDA tools.

    Capabilities:
    - Generate Yosys synthesis scripts
    - Generate OpenSTA timing analysis scripts
    - Validate scripts via dry-run
    - Parse tool output for errors
    - Learn from RAG documentation
    """

    def __init__(self, config: Optional[Dict] = None, rag_retriever=None):
        """
        Initialize A6 agent.

        Args:
            config: Configuration dict
            rag_retriever: Optional RAG retriever for documentation lookup
        """
        super().__init__(
            agent_id="A6",
            agent_name="EDA Command Copilot",
            config=config
        )

        self.rag_retriever = rag_retriever
        self.yosys_binary = config.get('yosys_binary', 'yosys') if config else 'yosys'
        self.opensta_binary = config.get('opensta_binary', 'sta') if config else 'sta'

        # Template library for common commands
        self.templates = self._load_templates()

        logger.info(f"A6 initialized with Yosys={self.yosys_binary}, OpenSTA={self.opensta_binary}")

    def _load_templates(self) -> Dict[str, str]:
        """Load TCL script templates"""
        return {
            'yosys_synthesis': """# Yosys Synthesis Script
# Generated by A6 EDA Command Copilot

# Read RTL files
{read_commands}

# Elaborate design
hierarchy -check -top {top_module}

# Generic synthesis
proc; opt; fsm; opt; memory; opt

# Technology mapping
{tech_mapping}

# Optimization
{optimization}

# Statistics
stat

# Write output
write_verilog {output_file}
""",

            'opensta_timing': """# OpenSTA Timing Analysis Script
# Generated by A6 EDA Command Copilot

# Read liberty libraries
{liberty_commands}

# Read verilog netlist
read_verilog {netlist_file}

# Link design
link_design {top_module}

# Read SDC constraints
read_sdc {sdc_file}

# Read parasitics (if available)
{spef_command}

# Report timing
report_checks -path_delay max -format full_clock_expanded
report_checks -path_delay min -format full_clock_expanded
report_worst_slack
report_tns
report_power
""",

            'verilator_lint': """# Verilator Lint Check
# Generated by A6 EDA Command Copilot

verilator --lint-only -Wall {verilog_files} --top-module {top_module}
"""
        }

    def process(self, input_data: Dict[str, Any]) -> AgentOutput:
        """
        Generate EDA command script from design intent.

        Args:
            input_data: Dict conforming to run_request schema

        Returns:
            AgentOutput with generated script and validation results
        """
        start_time = time.time()

        # Validate input
        if not self.validate_input(input_data):
            return self.create_output(
                success=False,
                output_data={},
                errors=["Invalid input data"],
                execution_time_ms=0
            )

        tool = input_data.get('tool', 'yosys')
        command_type = input_data.get('command_type', 'synthesis')

        logger.info(f"A6 generating {tool} script for {command_type}")

        # Retrieve relevant documentation from RAG
        context = self._get_rag_context(tool, command_type)

        # Generate script
        if tool == 'yosys':
            script, errors, warnings = self._generate_yosys_script(input_data, context)
        elif tool == 'opensta':
            script, errors, warnings = self._generate_opensta_script(input_data, context)
        elif tool == 'verilator':
            script, errors, warnings = self._generate_verilator_script(input_data, context)
        else:
            return self.create_output(
                success=False,
                output_data={},
                errors=[f"Unsupported tool: {tool}"]
            )

        # Validate script (dry-run if requested)
        if input_data.get('dry_run', False) and script:
            validation_result = self._validate_script(tool, script)
            errors.extend(validation_result['errors'])
            warnings.extend(validation_result['warnings'])

        execution_time = (time.time() - start_time) * 1000

        output_data = {
            'script_content': script,
            'tool': tool,
            'command_type': command_type,
            'validation': 'passed' if not errors else 'failed',
            'rag_context_used': len(context) if context else 0
        }

        success = len(errors) == 0 and script is not None

        return self.create_output(
            success=success,
            output_data=output_data,
            errors=errors,
            warnings=warnings,
            execution_time_ms=execution_time,
            metadata={'template': f'{tool}_{command_type}'}
        )

    def _get_rag_context(self, tool: str, command_type: str) -> Optional[str]:
        """
        Retrieve relevant documentation from RAG system.

        Args:
            tool: Tool name (yosys, opensta, etc.)
            command_type: Type of command

        Returns:
            Retrieved documentation context
        """
        if not self.rag_retriever:
            return None

        query = f"{tool} {command_type} syntax examples commands"

        try:
            results = self.rag_retriever.retrieve(query, top_k=3)
            if results:
                context = "\n\n".join([doc.get('content', '') for doc in results])
                logger.debug(f"Retrieved {len(results)} RAG documents for {tool}")
                return context
        except Exception as e:
            logger.warning(f"RAG retrieval failed: {e}")

        return None

    def _generate_yosys_script(
        self,
        input_data: Dict[str, Any],
        context: Optional[str]
    ) -> Tuple[Optional[str], List[str], List[str]]:
        """
        Generate Yosys synthesis script.

        Returns:
            (script_content, errors, warnings)
        """
        errors = []
        warnings = []

        # Extract parameters
        input_files = input_data.get('input_files', [])
        output_files = input_data.get('output_files', [])
        params = input_data.get('parameters', {})

        if not input_files:
            errors.append("No input RTL files specified")
            return None, errors, warnings

        if not output_files:
            warnings.append("No output file specified, using default 'output.v'")
            output_file = 'output.v'
        else:
            output_file = output_files[0]

        top_module = params.get('top_module', 'top')
        optimization_goal = params.get('optimization_goal', 'balanced')
        tech_lib = params.get('tech_library')

        # Build read commands
        read_commands = []
        for f in input_files:
            if f.endswith('.sv') or f.endswith('.svh'):
                read_commands.append(f"read_verilog -sv {f}")
            else:
                read_commands.append(f"read_verilog {f}")

        # Build technology mapping
        if tech_lib:
            tech_mapping = f"dfflibmap -liberty {tech_lib}\nabc -liberty {tech_lib}"
        else:
            tech_mapping = "# No technology library specified\n# Using generic mapping\nabc -g AND,NAND,OR,NOR,XOR,XNOR"
            warnings.append("No technology library specified, using generic gates")

        # Build optimization commands based on goal
        optimization_map = {
            'speed': 'opt; opt_clean -purge',
            'area': 'opt; opt_clean -purge; opt -full',
            'power': 'opt; opt_clean -purge',
            'balanced': 'opt'
        }
        optimization = optimization_map.get(optimization_goal, 'opt')

        # Fill template
        script = self.templates['yosys_synthesis'].format(
            read_commands='\n'.join(read_commands),
            top_module=top_module,
            tech_mapping=tech_mapping,
            optimization=optimization,
            output_file=output_file
        )

        return script, errors, warnings

    def _generate_opensta_script(
        self,
        input_data: Dict[str, Any],
        context: Optional[str]
    ) -> Tuple[Optional[str], List[str], List[str]]:
        """
        Generate OpenSTA timing analysis script.

        Returns:
            (script_content, errors, warnings)
        """
        errors = []
        warnings = []

        params = input_data.get('parameters', {})

        netlist_file = params.get('netlist_file')
        sdc_file = params.get('sdc_file')
        lib_files = params.get('lib_files', [])
        spef_file = params.get('spef_file')
        top_module = params.get('top_module', 'top')

        if not netlist_file:
            errors.append("No netlist file specified")
            return None, errors, warnings

        if not sdc_file:
            warnings.append("No SDC file specified, timing may be incomplete")
            sdc_file = ""

        if not lib_files:
            errors.append("No liberty files specified")
            return None, errors, warnings

        # Build liberty commands
        liberty_commands = []
        for lib_file in lib_files:
            liberty_commands.append(f"read_liberty {lib_file}")

        # SPEF command (optional)
        spef_command = ""
        if spef_file:
            spef_command = f"read_spef {spef_file}"
        else:
            spef_command = "# No SPEF file provided (wire RC parasitics)"

        # Fill template
        script = self.templates['opensta_timing'].format(
            liberty_commands='\n'.join(liberty_commands),
            netlist_file=netlist_file,
            top_module=top_module,
            sdc_file=sdc_file if sdc_file else "# No SDC file",
            spef_command=spef_command
        )

        return script, errors, warnings

    def _generate_verilator_script(
        self,
        input_data: Dict[str, Any],
        context: Optional[str]
    ) -> Tuple[Optional[str], List[str], List[str]]:
        """
        Generate Verilator lint command.

        Returns:
            (script_content, errors, warnings)
        """
        errors = []
        warnings = []

        input_files = input_data.get('input_files', [])
        params = input_data.get('parameters', {})
        top_module = params.get('top_module', 'top')

        if not input_files:
            errors.append("No input files specified")
            return None, errors, warnings

        verilog_files = ' '.join(input_files)

        script = self.templates['verilator_lint'].format(
            verilog_files=verilog_files,
            top_module=top_module
        )

        return script, errors, warnings

    def _validate_script(self, tool: str, script: str) -> Dict[str, Any]:
        """
        Validate script via dry-run.

        Args:
            tool: Tool name
            script: Script content

        Returns:
            Dict with 'errors' and 'warnings'
        """
        result = {'errors': [], 'warnings': []}

        # Create temp file for script
        with tempfile.NamedTemporaryFile(
            mode='w',
            suffix='.tcl',
            delete=False
        ) as f:
            f.write(script)
            script_path = f.name

        try:
            if tool == 'yosys':
                # Yosys dry-run: just syntax check
                cmd = [self.yosys_binary, '-p', 'help']
                subprocess.run(cmd, capture_output=True, text=True, timeout=5, check=True)
                result['warnings'].append("Yosys syntax validation passed (basic check)")

            elif tool == 'opensta':
                # OpenSTA dry-run
                cmd = [self.opensta_binary, '-version']
                subprocess.run(cmd, capture_output=True, text=True, timeout=5, check=True)
                result['warnings'].append("OpenSTA binary accessible")

        except subprocess.TimeoutExpired:
            result['errors'].append(f"{tool} validation timed out")
        except subprocess.CalledProcessError as e:
            result['errors'].append(f"{tool} validation failed: {e.stderr}")
        except FileNotFoundError:
            result['warnings'].append(f"{tool} binary not found, skipping validation")
        finally:
            # Clean up temp file
            Path(script_path).unlink(missing_ok=True)

        return result

    def validate_input(self, input_data: Dict[str, Any]) -> bool:
        """
        Validate input against run_request schema.

        Args:
            input_data: Input to validate

        Returns:
            True if valid
        """
        required_fields = ['tool', 'command_type']

        for field in required_fields:
            if field not in input_data:
                logger.error(f"Missing required field: {field}")
                return False

        valid_tools = ['yosys', 'opensta', 'verilator', 'dreamplace', 'tritonroute']
        if input_data['tool'] not in valid_tools:
            logger.error(f"Invalid tool: {input_data['tool']}")
            return False

        return True

    def get_schema(self) -> Dict[str, Any]:
        """Return input schema for A6"""
        # Load run_request schema
        schema_path = Path(__file__).parent.parent / 'schemas' / 'run_request.json'

        try:
            with open(schema_path, 'r') as f:
                return json.load(f)
        except Exception as e:
            logger.error(f"Failed to load schema: {e}")
            return {}
